<!doctype html>
<html>
	<head>
		<meta charset="utf-8" />
		<meta http-equiv="Pragma" content="no-cache" />
		<meta http-equiv="Expires" content="-1" />
		<script type="module">
/*
 * Push the shared Emscripten API exports into the global scope (we use them
 * from both the web worklet and here, and with the same HEAPU32).
 */
import * as Emscripten from "./emscripten-api.js";
for (var func in Emscripten) {
	globalThis[func] = Emscripten[func];
}
		</script>
		<title>Lock Bug Test</title>
		<script>

// Emulating Emscripten's heap
const wasmMemory = new SharedArrayBuffer(1024);
const HEAPU32 = new Uint32Array(wasmMemory);
const HEAP32 = new Int32Array(wasmMemory);

const Test = {
	'TEST_LOADING': 0,           // The page is still loading
	'TEST_NOT_STARTED': 1,       // The test hasn't yet started
	'TEST_TRY_ACQUIRE': 2,       // Acquired in main, fail in process()
	'TEST_WAIT_ACQUIRE_FAIL': 3, // Keep acquired so time-out
	'TEST_WAIT_ACQUIRE': 4,      // Release in main, succeed in process()
	'TEST_RELEASE': 5,           // Release in process() after above
	'TEST_DONE': 6,              // Test finished
};

// Style for the mainLoop log (magenta)
const CSS_MAIN = "color: #F0F";

// Lock used in all the tests (address in HEAPU32.buffer)
const testLock = 0;
// Which test is running (sometimes in the worklet, sometimes in the main thread; address in HEAPU32.buffer)
const whichTest = 4;

// Time at which the test starts, taken in main()
var startTime = 0;
// Has TEST_WAIT_ACQUIRE unlocked testLock?
var waitAcquireUnlocked = false;

// Audio context (created in main())
var audioContext = null;
// AudioWorkletNode attached to the audio context (to query or post a message)
var workletNode = null;

/*
 * Called every 10ms-ish using a timeout.
 */
function mainLoop(time, data) {
	emscripten_outf("%c*** enter mainLoop()", CSS_MAIN);
	assert(!emscripten_current_thread_is_audio_worklet()
		&& !_emscripten_thread_supports_atomics_wait());
	var runAgain = true;
	var timeTook = 0;
	switch (emscripten_atomic_load_u32(whichTest)) {
	case Test.TEST_LOADING:
		// Wait until the AudioWorkletProcessor (AWP) has loaded
		emscripten_outf("%cTEST_LOADING: Still loading", CSS_MAIN);
		break;
	case Test.TEST_NOT_STARTED:
		// We're loaded, let the AWP know to start
		emscripten_outf("%cTEST_NOT_STARTED: Staring test", CSS_MAIN);
		emscripten_atomic_store_u32(whichTest, Test.TEST_TRY_ACQUIRE);
		break;
	case Test.TEST_TRY_ACQUIRE:
		emscripten_outf("%cTEST_TRY_ACQUIRE: main nothing to do (waiting on AW starting)", CSS_MAIN);
		break;
	case Test.TEST_WAIT_ACQUIRE_FAIL:
		emscripten_outf("%cTEST_WAIT_ACQUIRE_FAIL: main nothing to do", CSS_MAIN);
		break;
	case Test.TEST_WAIT_ACQUIRE:
		if (!waitAcquireUnlocked) {
			// Release here to acquire in process()
			emscripten_outf("%cTEST_WAIT_ACQUIRE: main releasing lock", CSS_MAIN);
			emscripten_lock_release(testLock);
			emscripten_outf("%cTEST_WAIT_ACQUIRE: main released", CSS_MAIN);
			waitAcquireUnlocked = true;
		} else {
			emscripten_outf("%cTEST_WAIT_ACQUIRE: main already unlocked", CSS_MAIN);
		}
		break;
	case Test.TEST_RELEASE:
		emscripten_outf("%cTEST_RELEASE: main nothing to do", CSS_MAIN);
		break;
	default:
		// Finished, exit from the main thread
		timeTook = emscripten_get_now() - startTime;
		emscripten_outf("%cTEST_DONE: %dms (expect: > 100)", CSS_MAIN, timeTook);
		runAgain = false;
	}
	emscripten_outf("%c*** exit mainLoop()", CSS_MAIN);
	return runAgain;
}

function main() {
	if (audioContext) {
		emscripten_out("This was designed to run once, reload the page");
		return;
	}
	/*
	 * The basics: do locks work?
	 */
	emscripten_lock_init(testLock);
	var hasLock = emscripten_lock_busyspin_wait_acquire(testLock, 0);
	assert(hasLock);
	/*
	 * Then prepare to run (note the mimic of '_Atomic Test whichTest')
	 */
	emscripten_atomic_store_u32(whichTest, Test.TEST_LOADING);
	startTime = emscripten_get_now();
	/*
	 * Wraps up all the audio worklet creation:
	 *
	 *	emscripten_create_audio_context()
	 *	emscripten_start_wasm_audio_worklet_thread_async()
	 *	emscripten_create_wasm_audio_worklet_processor_async()
	 *	emscripten_create_wasm_audio_worklet_node()
	 *	emscripten_audio_node_connect()
	 *
	 * And we pass to the worklet the heap, Test enums, lock and which test
	 * addresses (the AudioWorkletProcessor has the Emscripten API imported).
	 */
	audioContext = new AudioContext();
	assert(audioContext);
	audioContext.audioWorklet.addModule("test-processor.js").then(() => {
		workletNode = new AudioWorkletNode(audioContext, "test-processor", {
			processorOptions: {
				HEAPU32,
				HEAP32,
				Test,
				testLock,
				whichTest,
			}
		});
		workletNode.connect(audioContext.destination);
	});
	/*
	 * Keep this the same as the C version and let mainLoop watch 'whichTest'.
	 */
	emscripten_set_timeout_loop(mainLoop, 10, null);
}

		</script>
	</head>
	<body>
		<p>Click to start the test, results are in the console.</p>
		<button type="button" onclick="main()">Start Test</button>
	</body>
</html>
