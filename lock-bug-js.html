<!doctype html>
<html>
	<head>
		<meta charset="utf-8" />
		<meta http-equiv="Pragma" content="no-cache" />
		<meta http-equiv="Expires" content="-1" />
		<script type="module">
/*
 * Push the shared Emscripten API exports into the global scope (we use them
 * from both the web worklet and here, and with the same HEAPU32).
 */
import * as Emscripten from "./emscripten-api.js";
for (var api in Emscripten) {
	globalThis[api] = Emscripten[api];
}
		</script>
		<title>Lock Bug JavaScript Test</title>
		<script>

// Emulating Emscripten's heap
const wasmMemory = new SharedArrayBuffer(1024);
const HEAPU32 = new Uint32Array(wasmMemory);
const HEAP32 = new Int32Array(wasmMemory);

const Test = {
	"TEST_LOADING"          : 0, // The page is still loading
	"TEST_NOT_STARTED"      : 1, // The test hasn't yet started
	"TEST_TRY_ACQUIRE"      : 2, // Acquired in main, fail in process()
	"TEST_WAIT_ACQUIRE_FAIL": 3, // Keep acquired so time-out
	"TEST_WAIT_ACQUIRE"     : 4, // Release in main, succeed in process()
	"TEST_RELEASE"          : 5, // Release in process() after above
	"TEST_DONE"             : 6, // Test finished
};

// Style for the mainLoop log (magenta)
var STYLE_MAIN = "\x1B[95m";

// Lock used in all the tests (address in HEAPU32.buffer)
const testLock = 0;
// Which test is running (sometimes in the worklet, sometimes in the main thread; address in HEAPU32.buffer)
const whichTest = 4;

// Time at which the test starts, taken in runTest()
var startTime = 0;
// Has TEST_WAIT_ACQUIRE unlocked testLock?
var waitAcquireUnlocked = false;

// Audio context (created in main())
var audioContext = null;
// AudioWorkletNode attached to the audio context (to query or post a message)
var workletNode = null;

// Called every 10ms-ish using a timeout
function mainLoop(time, data) {
	emscripten_outf("%s*** enter mainLoop()", STYLE_MAIN);
	var runAgain = true;
	switch (emscripten_atomic_load_u32(whichTest)) {
	case Test.TEST_LOADING:
		// Wait until the AudioWorkletProcessor (AWP) has loaded
		emscripten_outf("%sTEST_LOADING: Still loading", STYLE_MAIN);
		break;
	case Test.TEST_NOT_STARTED:
		assert(!emscripten_current_thread_is_audio_worklet()
			&& !_emscripten_thread_supports_atomics_wait());
		// The AWP has loaded, so move to the first test
		emscripten_outf("%sTEST_NOT_STARTED: Staring test (is AW: %d, has wait: %d, expect 0 & 0)",
			STYLE_MAIN, emscripten_current_thread_is_audio_worklet(),
				_emscripten_thread_supports_atomics_wait());
		emscripten_atomic_store_u32(whichTest, Test.TEST_TRY_ACQUIRE);
		break;
	case Test.TEST_TRY_ACQUIRE:
		emscripten_outf("%sTEST_TRY_ACQUIRE: main nothing to do (waiting on AW starting)", STYLE_MAIN);
		break;
	case Test.TEST_WAIT_ACQUIRE_FAIL:
		emscripten_outf("%sTEST_WAIT_ACQUIRE_FAIL: main nothing to do", STYLE_MAIN);
		break;
	case Test.TEST_WAIT_ACQUIRE:
		if (!waitAcquireUnlocked) {
			// Release here to acquire in process()
			emscripten_outf("%sTEST_WAIT_ACQUIRE: main releasing lock", STYLE_MAIN);
			emscripten_lock_release(testLock);
			emscripten_outf("%sTEST_WAIT_ACQUIRE: main lock released", STYLE_MAIN);
			waitAcquireUnlocked = true;
		} else {
			emscripten_outf("%sTEST_WAIT_ACQUIRE: main already unlocked", STYLE_MAIN);
		}
		break;
	case Test.TEST_RELEASE:
		emscripten_outf("%sTEST_RELEASE: main nothing to do", STYLE_MAIN);
		break;
	default:
		// Finished, exit from the main thread
		emscripten_outf("%sTEST_DONE: %dms (expect: > 100)", STYLE_MAIN, emscripten_get_now() - startTime);
		runAgain = false;
	}
	emscripten_outf("%s*** exit mainLoop()", STYLE_MAIN);
	return runAgain;
}

// Called on the button click
function runTest() {
	if (audioContext) {
		emscripten_out("This was designed to run once, reload the page");
		return;
	}
	if (getBrowser() != Browser.BROWSER_CHROME) {
		// No ANSI colours if this isn't Chrome
		STYLE_MAIN = "";
	}
	/*
	 * The basics: do locks work?
	 */
	emscripten_lock_init(testLock);
	var hasLock = emscripten_lock_busyspin_wait_acquire(testLock, 0);
	assert(hasLock);
	/*
	 * Then prepare to run (note the mimic of '_Atomic Test whichTest')
	 */
	emscripten_atomic_store_u32(whichTest, Test.TEST_LOADING);
	startTime = emscripten_get_now();
	/*
	 * Wraps up all the audio worklet creation:
	 *
	 *	emscripten_create_audio_context()
	 *	emscripten_start_wasm_audio_worklet_thread_async()
	 *	emscripten_create_wasm_audio_worklet_processor_async()
	 *	emscripten_create_wasm_audio_worklet_node()
	 *	emscripten_audio_node_connect()
	 *
	 * And we pass to the worklet the heap, Test enums, lock and which test
	 * addresses (the AudioWorkletProcessor has the Emscripten API imported).
	 */
	audioContext = new AudioContext();
	assert(audioContext);
	audioContext.audioWorklet.addModule("test-processor.js").then(() => {
		workletNode = new AudioWorkletNode(audioContext, "test-processor", {
			processorOptions: {
				HEAPU32,
				HEAP32,
				Test,
				testLock,
				whichTest,
				userAgent: navigator.userAgent,
			}
		});
		workletNode.connect(audioContext.destination);
	});
	/*
	 * Keep this the same as the C version and let mainLoop watch 'whichTest'.
	 */
	emscripten_set_timeout_loop(mainLoop, 10, null);
}

		</script>
	</head>
	<body>
		<p>Click to start the test, results are in the console.</p>
		<button type="button" onclick="runTest()">Start Test</button>
	</body>
</html>
